import os
from flask import Flask, render_template, request, url_for, jsonify # <-- Importa jsonify
from google.cloud import texttospeech

app = Flask(__name__)

# ... (código existente para crear 'static' y el cliente)
client = texttospeech.TextToSpeechClient()

# Diccionario para cachear las voces y no llamar a la API cada vez
voices_cache = {}

@app.route('/', methods=['GET'])
def index():
    return render_template('index.html')

@app.route('/get_voices', methods=['GET'])
def get_voices():
    """Endpoint para obtener las voces disponibles y agruparlas por idioma."""
    global voices_cache
    # Si ya tenemos las voces en caché, las devolvemos directamente
    if voices_cache:
        return jsonify(voices_cache)

    # Si no, las pedimos a la API de Google
    response = client.list_voices()
    voices_by_language = {}

    for voice in response.voices:
        # Filtramos para quedarnos con voces de alta calidad como WaveNet o Neural2
        if "Wavenet" in voice.name or "Neural2" in voice.name:
            lang_code = voice.language_codes[0]
            if lang_code not in voices_by_language:
                voices_by_language[lang_code] = []
            
            voices_by_language[lang_code].append({
                "name": voice.name,
                # Convierte el enum de género a un string simple
                "gender": texttospeech.SsmlVoiceGender(voice.ssml_gender).name
            })
    
    # Guardamos en caché para futuras peticiones
    voices_cache = voices_by_language
    return jsonify(voices_by_language)


@app.route('/synthesize', methods=['POST'])
def synthesize():
    # ... (tu función synthesize se mantiene igual)
    text = request.form['text']
    language_code = request.form['language']
    voice_name = request.form['voice']

    synthesis_input = texttospeech.SynthesisInput(text=text)

    voice = texttospeech.VoiceSelectionParams(
        language_code=language_code,
        name=voice_name
    )

    audio_config = texttospeech.AudioConfig(
        audio_encoding=texttospeech.AudioEncoding.MP3
    )

    response = client.synthesize_speech(
        input=synthesis_input, voice=voice, audio_config=audio_config
    )

    audio_file = "output.mp3"
    static_audio_path = os.path.join("static", audio_file)
    with open(static_audio_path, "wb") as out:
        out.write(response.audio_content)
        print(f'Audio content written to file "{static_audio_path}"')

    return render_template('index.html', audio_file=audio_file)

if __name__ == '__main__':
    app.run(debug=True)